# -*- coding: utf-8 -*-
"""project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XcYqnGCFOIGrWwWNBlXh9FqY51YAKvJR
"""

# !pip install yt-dlp openai-whisper

import smtplib
from email.mime.text import MIMEText
import json
import argparse
from pathlib import Path
from typing import List, Optional
from crewai import Agent, Task, Crew, Process,LLM
from crewai.tools import BaseTool, tool
from pydantic import BaseModel, Field, ValidationError
import torch
from transformers import pipeline
import subprocess
import os
from langchain_google_genai import ChatGoogleGenerativeAI
from dotenv import load_dotenv
from typing import Dict


# url = "https://youtu.be/rOqgRiNMVqg?si=Ytuo3W9I884u3laJ"
# output_folder = "my_audio_folder"
# os.makedirs(output_folder, exist_ok=True)
# command = [
#     "yt-dlp",
#     "-f", "bestaudio/best",
#     "--extract-audio",
#     "--audio-format", "mp3",
#     "--audio-quality", "0",  # 0 = best
#     "-o", f"{output_folder}/%(title)s.%(ext)s",
#     url
# ]
# subprocess.run(command)

# !pip install crewai['tools'] pip install python-dotenv


# !pip install transformers

# !pip install langchain_google_genai

load_dotenv()

api=os.getenv('API')
os.environ["GEMINI_API_KEY"]= api
os.environ["OPENAI_API_KEY"] = os.environ["GEMINI_API_KEY"]
os.environ["OPENAI_API_BASE"] = "https://generativelanguage.googleapis.com/v1beta/openai/"

llm=LLM(model="gemini/gemini-2.0-flash",
        temperature=0.1,
        )

device = "cuda:0" if torch.cuda.is_available() else "cpu"

pipe = pipeline(
  "automatic-speech-recognition",
  model="openai/whisper-tiny",
  chunk_length_s=30,  
  device=device,
)

# result = pipe("my_audio_folder/Sec Growth DataScience staff meeting Sep 14 2022.mp3")

# text=result['text']

def transcribe(audio_file_path: str) -> Dict:
    """Transcribe audio into text using Whisper."""
    result = pipe(audio_file_path)
    return {"text": result["text"]}


def send_email(subject, body, sender, receiver, password):
    msg = MIMEText(body, "plain")  
    msg["From"] = sender
    msg["To"] = receiver
    msg["Subject"] = subject

    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
        server.login(sender, password)
        server.sendmail(sender, receiver, msg.as_string())



# ----- 1) Define a clean args schema (string, not dict)
class MailerToolSchema(BaseModel):
    body: str = Field(..., description="Full email body to send (plain text or markdown).")

# ----- 2) Tool: accept 'body' directly
class MailerTool(BaseTool):
    name: str = "mailer_tool"
    description: str = "Send a drafted meeting summary email via Gmail SMTP."
    args_schema = MailerToolSchema

    def _run(self, body: str) -> str:
        body = (body or "").strip()
        if not body:
            return "Error: No email draft provided."

        subject = "Meeting Summary & Action Items"
        sender = os.getenv("SMTP_EMAIL")
        receiver = os.getenv("SMTP_RECEIVER")
        password = os.getenv("SMTP_PASSWORD")

        if not sender or not receiver or not password:
            return (
                "Error: Missing SMTP credentials. "
                "Please set SMTP_EMAIL, SMTP_RECEIVER, SMTP_PASSWORD env vars."
            )

        send_email(subject, body, sender, receiver, password)
        return "Email sent successfully!"


SummarizerAgent = Agent(
role="Summarizer",
goal="Summarize transcript into structured meeting minutes",
backstory="You are an expert note-taker who extracts decisions, discussions, agreements, and risks.",
llm=llm
)

ActionItemAgent = Agent(
    role="Action Extractor",
    goal="Extract action items in strict JSON schema",
    backstory="You always produce valid JSON according to schema.",
    llm=llm,
)

EmailAgent = Agent(
    role="Email Drafter",
    goal="Write a professional follow-up email with summary + tasks",
    backstory="You draft clear, concise follow-up emails after meetings.",
    llm=llm,
)

MailerAgent = Agent(
    role="Mailer",
    goal="Send the drafted email to the recipient using SMTP.",
    backstory="You are responsible for sending professional emails reliably.",
    llm=llm,
    tools=[MailerTool()]  # <â€” attach here so all Mailer tasks can use it
)

SummarizationTask = Task(
    description="Summarize this meeting transcript:\n\n{{transcript}}",
    expected_output="Markdown with sections: Decisions, Discussions, Agreements, Risks, Next Steps.",
    agent=SummarizerAgent,
)

ActionItemsTask = Task(
    description=(
        "From the summary above, extract action items strictly in JSON schema:\n"
        "{ 'items': [ { 'task': str, 'owner': str, 'deadline': str|null } ] }"
    ),
    expected_output="Valid JSON following schema.",
    agent=ActionItemAgent,
    context=[SummarizationTask],
)
# ----- 4) Make the email draft come out as plain text (no code fences) -----
EmailDraftTask = Task(
    description=(
        "Write a professional follow-up email based on the meeting summary and action items. "
        "Return ONLY the email body as plain text (no code fences, no backticks)."
    ),
    expected_output="Plain text email body ready to send.",
    agent=EmailAgent,
    context=[SummarizationTask, ActionItemsTask],
)

# ----- 5) Tell the Mailer task exactly how to call the tool -----
MailerTask = Task(
    description=(
        "Send the drafted email to the recipient via Gmail SMTP using the mailer_tool.\n\n"
        "Use this exact format:\n"
        "Thought: decide to send the email\n"
        "Action: mailer_tool\n"
        "Action Input: {\"body\": \"{{the plain text email body from context}}\"}\n"
        "Observation: tool result"
    ),
    expected_output="Confirmation that the email was sent.",
    agent=MailerAgent,
    context=[EmailDraftTask]
)








# crew = Crew(
#     agents=[SummarizerAgent,ActionItemAgent,EmailAgent,MailerAgent],
#     tasks=[SummarizationTask,ActionItemsTask,EmailDraftTask,MailerTask],
#     verbose=True

# )
# results = crew.kickoff(inputs={"transcript": text})

# print(dir(results))

# # for i, task_output in enumerate(results.tasks_output, start=1):
# #     print(f"Task {i}:", task_output)

# task_outputs = {}

# for i, task_output in enumerate(results.tasks_output, start=1):
#     var_name = f"task{i}_output"
#     task_outputs[var_name] = task_output

# # print(task_outputs["task1_output"])
# print(task_outputs["task2_output"])
# #print(task_outputs["task3_output"])
# print(task_outputs["task4_output"])

